// Code generated by skv2. DO NOT EDIT.

// Definitions for the multicluster Kubernetes Controllers
package controller

import (
	"context"

	simple_skv2_solo_io_v1alpha1 "github.com/solo-io/solo-kit-example/simple/pkg/api/simple.skv2.solo.io/v1alpha1"

	"github.com/pkg/errors"
	"github.com/solo-io/skv2/pkg/ezkube"
	"github.com/solo-io/skv2/pkg/multicluster"
	mc_reconcile "github.com/solo-io/skv2/pkg/multicluster/reconcile"
	"github.com/solo-io/skv2/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
)

// Reconcile Upsert events for the Circle Resource across clusters.
// implemented by the user
type MulticlusterCircleReconciler interface {
	ReconcileCircle(clusterName string, obj *simple_skv2_solo_io_v1alpha1.Circle) (reconcile.Result, error)
}

// Reconcile deletion events for the Circle Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterCircleDeletionReconciler interface {
	ReconcileCircleDeletion(clusterName string, req reconcile.Request)
}

type MulticlusterCircleReconcilerFuncs struct {
	OnReconcileCircle         func(clusterName string, obj *simple_skv2_solo_io_v1alpha1.Circle) (reconcile.Result, error)
	OnReconcileCircleDeletion func(clusterName string, req reconcile.Request)
}

func (f *MulticlusterCircleReconcilerFuncs) ReconcileCircle(clusterName string, obj *simple_skv2_solo_io_v1alpha1.Circle) (reconcile.Result, error) {
	if f.OnReconcileCircle == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileCircle(clusterName, obj)
}

func (f *MulticlusterCircleReconcilerFuncs) ReconcileCircleDeletion(clusterName string, req reconcile.Request) {
	if f.OnReconcileCircleDeletion == nil {
		return
	}
	f.OnReconcileCircleDeletion(clusterName, req)
}

type MulticlusterCircleReconcileLoop interface {
	// AddMulticlusterCircleReconciler adds a MulticlusterCircleReconciler to the MulticlusterCircleReconcileLoop.
	AddMulticlusterCircleReconciler(ctx context.Context, rec MulticlusterCircleReconciler, predicates ...predicate.Predicate)
}

type multiclusterCircleReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterCircleReconcileLoop) AddMulticlusterCircleReconciler(ctx context.Context, rec MulticlusterCircleReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericCircleMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterCircleReconcileLoop(name string, cw multicluster.ClusterWatcher) MulticlusterCircleReconcileLoop {
	return &multiclusterCircleReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &simple_skv2_solo_io_v1alpha1.Circle{})}
}

type genericCircleMulticlusterReconciler struct {
	reconciler MulticlusterCircleReconciler
}

func (g genericCircleMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) {
	if deletionReconciler, ok := g.reconciler.(MulticlusterCircleDeletionReconciler); ok {
		deletionReconciler.ReconcileCircleDeletion(cluster, req)
	}
}

func (g genericCircleMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*simple_skv2_solo_io_v1alpha1.Circle)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Circle handler received event for %T", object)
	}
	return g.reconciler.ReconcileCircle(cluster, obj)
}

// Reconcile Upsert events for the Square Resource across clusters.
// implemented by the user
type MulticlusterSquareReconciler interface {
	ReconcileSquare(clusterName string, obj *simple_skv2_solo_io_v1alpha1.Square) (reconcile.Result, error)
}

// Reconcile deletion events for the Square Resource across clusters.
// Deletion receives a reconcile.Request as we cannot guarantee the last state of the object
// before being deleted.
// implemented by the user
type MulticlusterSquareDeletionReconciler interface {
	ReconcileSquareDeletion(clusterName string, req reconcile.Request)
}

type MulticlusterSquareReconcilerFuncs struct {
	OnReconcileSquare         func(clusterName string, obj *simple_skv2_solo_io_v1alpha1.Square) (reconcile.Result, error)
	OnReconcileSquareDeletion func(clusterName string, req reconcile.Request)
}

func (f *MulticlusterSquareReconcilerFuncs) ReconcileSquare(clusterName string, obj *simple_skv2_solo_io_v1alpha1.Square) (reconcile.Result, error) {
	if f.OnReconcileSquare == nil {
		return reconcile.Result{}, nil
	}
	return f.OnReconcileSquare(clusterName, obj)
}

func (f *MulticlusterSquareReconcilerFuncs) ReconcileSquareDeletion(clusterName string, req reconcile.Request) {
	if f.OnReconcileSquareDeletion == nil {
		return
	}
	f.OnReconcileSquareDeletion(clusterName, req)
}

type MulticlusterSquareReconcileLoop interface {
	// AddMulticlusterSquareReconciler adds a MulticlusterSquareReconciler to the MulticlusterSquareReconcileLoop.
	AddMulticlusterSquareReconciler(ctx context.Context, rec MulticlusterSquareReconciler, predicates ...predicate.Predicate)
}

type multiclusterSquareReconcileLoop struct {
	loop multicluster.Loop
}

func (m *multiclusterSquareReconcileLoop) AddMulticlusterSquareReconciler(ctx context.Context, rec MulticlusterSquareReconciler, predicates ...predicate.Predicate) {
	genericReconciler := genericSquareMulticlusterReconciler{reconciler: rec}

	m.loop.AddReconciler(ctx, genericReconciler, predicates...)
}

func NewMulticlusterSquareReconcileLoop(name string, cw multicluster.ClusterWatcher) MulticlusterSquareReconcileLoop {
	return &multiclusterSquareReconcileLoop{loop: mc_reconcile.NewLoop(name, cw, &simple_skv2_solo_io_v1alpha1.Square{})}
}

type genericSquareMulticlusterReconciler struct {
	reconciler MulticlusterSquareReconciler
}

func (g genericSquareMulticlusterReconciler) ReconcileDeletion(cluster string, req reconcile.Request) {
	if deletionReconciler, ok := g.reconciler.(MulticlusterSquareDeletionReconciler); ok {
		deletionReconciler.ReconcileSquareDeletion(cluster, req)
	}
}

func (g genericSquareMulticlusterReconciler) Reconcile(cluster string, object ezkube.Object) (reconcile.Result, error) {
	obj, ok := object.(*simple_skv2_solo_io_v1alpha1.Square)
	if !ok {
		return reconcile.Result{}, errors.Errorf("internal error: Square handler received event for %T", object)
	}
	return g.reconciler.ReconcileSquare(cluster, obj)
}
